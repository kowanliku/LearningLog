## 第8章 字符输入/输出和输入确认

### 在本章中您将学习下列内容：
- 有关输入、输出以及缓冲和非缓冲输入的区别的更多内容。  
- 从键盘模拟文件结尾条件的方法。  
- 如何重定向将您的程序与文件相连接。
- 使用户界面更加友好。  


### 程序清单：
[1.echo.c (getchar与putchar)](C_Primer_Plus_code/801/main.c)  
[2.echo_eof.c (重复输入直到文件的结尾EOF)](C_Primer_Plus_code/802/main.c)  
[3.file_eof.c (打开文件)](C_Primer_Plus_code/803/main.c)  
[4.guess.c (缓冲输入响应次数)](C_Primer_Plus_code/804/main.c)  
[5.showchar1.c (getchar与scanf混合使用的情况)](C_Primer_Plus_code/805/main.c)  
[6.showchar2.c (使用循环剔除未知的缓冲区换行符)](C_Primer_Plus_code/806/main.c)  
[7.7checking.c (检查字符范围是否有效)](C_Primer_Plus_code/807/main.c)  
[8.menuette.c (菜单技术实现检查字符是否有效与重输入)](C_Primer_Plus_code/808/main.c)  

### 知识点：  

在计算机世界中，我们在很多场合下都使用词语输入(input)和输出(output)。例如，在讲输入和输出设备（如键盘、磁盘驱动器和激光打印机等）时，在指用于输入和输出的数据时，以及在执行输入和输出任务的函数时。本章集中讨论用于输入和输出（简称为I/O）的函数。  
  
  我们将集中讨论所有系统上都可用的标准I/O函数，因为这些函数可使您编写可移植的程序，这些程序易于从一个系统移植至另一个系统。这些函数还对使用文件进行输入和输出的程序普遍适用。

- 单字符I/O：getchar()和putchar()  
ANSI C将stdio.h头文件与使用getchar()和putchar()相关联，这就是我们在程序中将该文件包含在内的原因（典型地，getchar()和putchar()不是真正的函数，而是定义为预处理器宏。
  
- 缓冲区  
输入字符的立即回显是非缓冲(unbuffered)或者直接(direct)输入的一个实例，它表示您所键入的字符对正在等待的程序立即变为可用。相反，延迟回显是缓冲(buffered)输入的实例，这种情况下您所键入的字符被收集并存储在一个被称为缓冲区(buffer)的临时存储区域中。  

  为什么需要缓冲区？首先，将若干个字符作为一个块传输比逐个发送这些字符耗费的时间少。其次，如果您输入有误，就可以使用您的键盘更正功能来修正错误。当最终按下回车键时，您就可以发送正确的输入。  

  一些交互性的程序需要非缓冲输入。例如，在游戏中，您希望一按下键就执行某个命令。因此，缓冲和非缓冲输入具有它们各自的用途。  
  
  缓冲分为两类：完全缓冲(fully buffered)I/O和行缓冲(line-buffered)I/O。对完全缓冲输入来说，缓冲区满时被清空（内容被发送至其目的地）。这种类型的缓冲通常出现在文件输入中。缓冲区的大小取决于系统，但512字节和4096字节是常见的值。对行缓冲I/O来说，遇到一个换行字符时将被清空缓冲区。键盘输入是标准的行缓冲，因此按下回车键将清空缓冲区。  
  
  缓冲还是非缓冲？ANSI C指定应该对输入进行缓冲，而K&R则将选择权留给了编译器的编写者。ANSI C决定将缓冲输入作为标准的原因是一些计算机设计不允许非缓冲输入。如果您的特定计算机确实允许非缓冲输入，则很可能您的C编译器会提供非缓冲输入作为选项。Unix系统使用一种不同的方法，因为Unix自己控制缓冲。在Unix下，可以用ioctl()函数（Unix库的一部分，但不是标准C的一部分）来指定您所需要的输入类型，getchar()将按照该类型运行。
  
- 文件流  
文件(file)是一块存储信息的存储器区域。通常，文件被保存在某种类别的永久存储器上，例如软盘、硬盘或磁带。  

  具有强大、灵活等特点的C语言具有许多用于打开、读、写和关闭文件库函数。在一个级别上，他可以使用宿主操作系统的基本文件工具来处理文件。这被称为低级I/O(low-level I/O).由于计算机系统之间存在许多差异，所以不可能创建一个通用的低级I/O函数的标准库，而且ANSI C也不打算这样做；然而，C还以第二种级别处理文件，称为标准I/O包(standard I/O package)。这包括创建用于处理文件的I/O函数的标准模型和标准集。在这一较高级别上，系统之间的差异由特定的C实现来处理，所以您与之打交道的是一个统一接口。  
  
  我们提到的系统差异是哪些类型的呢？例如，不同的系统存储文件的方式不同。一些系统将文件存储在一个位置而将有关该文件的信息存储在另一个位置。而另一些系统在文件本身内建立其描述信息。处理文本时，一些系统使用单个的换行字符来标记一行的结束，而另一些系统则可能使用回车和换行字符的结合表示一行的结束。一些系统把文件大小衡量为最接近的字节数，而另一些则以字节块衡量文件大小。  
  
  使用标准I/O包时，就屏蔽掉了这些差异。因此，要检查一个换行符，您可以使用if(ch == '\n')。如果该系统实际上使用回车/换行字符的组合，则I/O函数自动在两种表示法之间来回转换。  
  
  从概念上说，C程序处理一个流而不是直接处理文件，流(stream)是一个理想化的数据流，实际输入或输出映射到这个数据流。这意味着具有不同属性的多种类型的输入由流表示，会具有更多统一的属性。于是打开文件的过程就成为将流与文件相关联，并通过流进行读写的过程。  
  
  键盘和显示器作为每个C程序自动打开的文件来对待。键盘输入由一个被称为stdin的流表示，而到屏幕（或电子打字机、或其他输出设备）上的输出由一个被称为stdout的流表示。getchar()、putchar()、printf()和scanf()函数都是标准I/O包的成员，这些函数同这两个流打交道。  
  
- 文件结尾  
C输入函数装备有一个内置的文件尾检测器。  

  计算机操作系统需要某种方式来断定每个文件起始和结束的位置。检测文件结尾的一种方法是在文件中放置一个特殊字符来标志结尾。操作系统可以使用一个内嵌的Ctrl + Z字符来标志文件结尾。这曾经是这些操作系统使用的唯一方法，但是现在还有其他的选择，例如根据文件的大小来断定文件的结束位置。所以现在的文本文件可能具有也可能没有内嵌Ctrl + Z，但如果该文件有，则操作系统就会将该字符作为文件尾标记对待。  

  第二种方法是操作系统存储文件大小的信息。如果一个文件具有3000字节，而程序已经读取了3000字节，则该程序就到达了文件尾。DOS的较新版本对文本文件也使用这种方法。Unix对所有文件都使用此方法。  
  
  对于这两种不同的方法，C的处理方法是让getchar()函数在到达文件结尾时返回一个特殊值，而不去管操作系统是如何检测文件结尾的。赋予该值的名称是EOF(End Of File，文件尾)。因此检测到文件尾时getchar()的返回值是EOF。scanf()函数在检测到文件结尾时也返回EOF。通常EOF在stdio.h文件中定义，如下表示：  
  ```#define EOF(-1)```
  
  为什么是-1？一般情况下，getchar()返回一个范围在0到127之间的值，因为这些值是与标准字符集相对应的值。但如果系统识别一个扩展的字符集，则可能返回从0到255的值。在每种情况中，值-1都不对应任何字符，所以可以用它来表示文件结尾。  
  
  ```while((ch = getchar()) != EOF)```
  
  - 不必定义EOF，因为stdio.h负责定义它。
  - 不必担心EOF的实际值，因为stdio.h中的#define语句使您能够使用EOF进行符号表示。不应编写假定EOF具有某个特定值的代码。
  - 变量ch从char类型改变为int类型。这是因为char变量可以由范围在0到255中的无符号整数来表示，但EOF可能具有数值-1.该值对无符号char变量是不可能的值，但对int则是可能的。幸运的是，getchar()本身的类型实际上是int，所以他可以读取EOF字符。在使用有符号char类型的实现中，将ch声明为char类型任然是可以的，但最好是使用更通用的形式。
  - ch是整数的事实不会对putchar()有任何影响。该函数仍打印与其相对应的字符。
  - 要对键盘输入使用此程序，您需要一种键入EOF字符的方式。不，您不能简单地输入字母E、O和F，而且您也不能只键入-1（键入-1会传送两个字符：一个连字符合数字1）。正确的方法是，您必须知道您的系统要求。例如，在大多数Unix系统上，在一行的开始键入Ctrl + D会导致传送文件尾信号。许多微型计算机系统将一行的开始位置的Ctrl + Z识别为文件尾信号，还有一些则把任意位置的Ctrl + Z解释成文件尾信号。  

  令程序与文件一同工作有两种方式。一种方式是明确地使用打开文件、关闭文件、读文件、写文件等等的专门函数。这种方法我们留待第13章讨论。第二种方式是使用一个设计用于与屏幕共同工作的程序，但是使用不同通道重定向(redirect)输入和输出，例如输入到文件和从文件中输出。  
  
  Unix、Linux和当前的DOS版本使您能够重定向输入和输出。输入重定向使您的程序能够使用文件代替键盘作为输入，输入出重定向则使程序能够使用文件代替屏幕作为输出。  
  
- 输入重定向  
```echo_eof < words```

  <符号是Unix、Linux和DOS的重定向运算符。该运算符把words文件与stdin流关联起来，将该文件的内容引导至程序。程序本身并不知道（或关心）输入是来自文件而不是来自键盘。该程序所知道的一切就是向它传送了一个字符流，所以它将这些字符读出并一次打印一个字符，直到遇到文件结尾。由于C将文件和I/O设备置于相同的地位，所以现在这个文件就是I/O设备。
  - 在Unix、Linux和DOS中，<两侧的空格都是可选的。有些系统（例如AmigaDOS）支持重定向，但在重定向符号和文件名之间不允许有空格。  

- 输出重定向  
```echo_eof > mywords```

  \>是另一个重定向运算符。该运算符会导致建立一个名为mywords的新文件供您使用，然后将echo_eof的输出（也就是说，您键入的字符的副本）重定向到该文件。该重定向将stdout从现实设备（您的屏幕）重定向到mywords文件。如果您已经具有一个名为mywords的文件，则通常会删除该文件然后用新的文件代替之（不过，许多操作系统都允许您通过将文本设为只读来保护现有的文件）。您键入字母时在您的屏幕上出现的就是这些字母，并且他们的副本将保存到文件中。要结束程序，请在一行的开始键入Ctrl + D（Unix中）或Ctrl + Z（DOS中）。  
  
- 组合重定向  
现在假设您希望制作文件mywords的一个副本，并将其命名为savewords。只需发出下列命令：  
```echo_eof < mywords > savewords```  
就可以完成这个动作。下面的命令同样可以实现这一功能，因为重定向运算符的顺序无关紧要：  
```echo_eof > savewords < mywords```  
注意不要对同一命令的输入和输出使用相同的文件名。  
```echo_eof < mywords > mywords...<--WRONG```  
原因是>mywords使原石的mywords文件在用于输入之前长度被截短为零。  

  简单地说，下面是在Unix、Linux或DOS下使用两个重定向运算符<和>所遵循的规则：
  - 重定向运算符将一个可执行(executable)程序（包括标准的操作系统命令）与一个数据文件连接起来。该运算符不能用于一个数据文件与另一个数据文件的连接，输出也不能定向至一个以上的文件。
  - 使用这些运算符时，输入不能来自一个以上的文件，输出也不能定向至一个以上的文件。
  - 除了偶尔在使用到一些对Unix shell、Linux shell或DOS具有特殊意义的字符时，名字和操作符之间的空格并不是必需的。例如，我们可以使用echo_eof<words  
  - 错误使用重定向的例子：  
  |||
  |---|---|
  |fish>beets|违反第一条规则|
  |addup<count|违反第一条规则|
  |addup<fish<beets|违反第二条规则|
  |count>beets fish|违反第二条规则|  

- 输入确认  
在实际情况中，程序的用户并不总是遵循指令，在程序所期望的输入与其实际获得的输入之间可能存在不匹配。这种情况能导致程序运行失败。然而，通常您可以预见可能的输入错误，而且，经过进行一些额外的编程努力，可以让程序检测到这些错误并对其进行处理。  


### 关键概念
C程序将输入视为一个外来字节的流。getchar()函数将每个字节解释为一个字符编码。scanf()函数以同样的方式看待输入，但在其转换说明符的指导下，该函数可以将字符转换为数值。许多操作系统都提供重定向，这就是您能够用文件代替键盘作为输入，或用文件代替显示器作为输出。  

  程序通常期望某种特定形式的输入。您可以通过设想用户可能犯的输入错误并令程序处理这些错误来使程序更加健壮和对用户更加友好。  
  
  对于一个小程序来说，输入确认可能是代码中最复杂的部分。在处理这个问题时可以由多种选择。例如，如果用户输入了错误的信息类型，则您可以终止程序，也可以给用户有限次数的机会进行正确输入，还可以给用户无限次机会进行正确输入。  
  

### 总结
许多程序使用getchar()来逐个字符地读取输入。通常，系统使用行缓冲输入（line-bufferedinput），这意味着输入的内容在您按下回车键时被传输给程序。按下回车键的同时还将传输一个编程时需要注意的换行字符。ANSI C把缓冲输入作为标准。  

  名为标准I/O包的一系列函数时C的一个特性，该函数系列以统一的方式处理不同系统上的不同文件格式。getchar()和scanf()函数属于这一函数系列。检测到文件尾时，这两个函数都返回EOF值（在stdio.h头文件中定义）。在Unix系统组，您能通过在一行的开始键入Ctrl+D来从键盘模拟文件结束条件；DOS系统则使用Ctrl+Z来达到这一目的。  
  
  许多操作系统（包括Unix和DOS）都具有重定向的特性，该特性使您能够使用文件代替键盘和屏幕作为输入和输出。这样，读取输入时以EOF为结束信号的程序就可以用于键盘输入和模拟的文件尾信号，或者用于重定向的文件。  
  
  如果混合使用scanf()和getchar()函数，那么当调用getchar()之前scanf()恰好在输入中留下一个换行符时，将会产生问题。然而，如果知道这个问题，就可以在编程中解决它。  
  
  当您编写程序时，要仔细地计划用户界面。尝试预见用户可能犯的错误类型，然后设计您的程序对其进行处理。  

### 复习题
1、putchar(getchar())是一个有效的表达式，它实现什么功能？getchar(putchar())也有效吗？  
<details>
     <summary>答：</summary>


 </details>  
<br/>  

2、下面的每个语句实现什么功能？  
```
    a.putchar('H');
    b.putchar('\007');
    c.putchar('\n');
    d.putchar('\b');
```
<details>
     <summary>答：</summary>


 </details>  
<br/>  

3、假设您有一个程序count，该程序对输入的字符进行统计。用count程序设计一个命令行命令，对文件essay中的字符进行计数并将结果保存在名为essayct的文件中。
<details>
     <summary>答：</summary>


 </details>  
<br/>  

4、给定问题3中的程序和文件，下面哪个命令是正确的？
<details>
     <summary>答：</summary>


 </details>  
<br/>  

5、EOF是什么？
<details>
     <summary>答：</summary>


 </details>  
<br/>  

6、对给出的输入，下面每个程序段的输出是什么（假定ch是int类型的，并且输入是缓冲的）？  
```
a. 输入如下所示：
    If you quit, I will.[enter]
    程序段如下所示：
    while ((ch = getchar()) != 'i')
            putchar(ch);
b. 输入如下所示：
    Harhar[enter]
    程序段如下所示：
    while ((ch = getchar()) != '\n')
    {
               putchar(ch++);
               putchar(++ch);
    }
```

<details>
     <summary>答：</summary>


 </details>  
<br/>  

7、C如何处理具有不同文件和换行约定的不同计算机系统？
<details>
     <summary>答：</summary>


 </details>  
<br/>  

8、在缓冲系统中把数值输入与字符输入相混合时，您所面临的潜在问题是什么？
<details>
     <summary>答：</summary>


 </details>  
<br/>  


### 编程练习
下面的一些程序要求输入以EOF终止。如果您的操作系统难以使用或不能使用重定向，则使用一些其他的判断来终止输入，例如读取&字符。  

1. 设计一个程序，统计从输入到文件结尾为止的字符数。  
[答题代码(8001)](C_Primer_Plus_code/8001/main.c)  

2. 编写一个程序，把输入作为字符流读取，直到遇到EOF。令该程序打印每个输入字符及其ASCII编码的十进制值。注意在ASCII序列中空格字符前面的字符是非打印字符，要特殊处理这些字符。如果非打印字符是换行符或制表符，则分期打印\n或\t。否则，使用控制字符符号。例如，ASCII的l是Ctrl+A，可以显示为AA。注意A的ASCⅡ值是Ctrl+A的值加64。对其他非打印字符也保持相似的关系。除去每次遇到一个换行符时就开始一个新行之外，每行打印10对值。  
[答题代码(8002)](C_Primer_Plus_code/8002/main.c)  

3. 编写一个程序，把输入作为字符流读取，直至遇到EOF。令其报告输入中的大写字母个数和小写字母个数。假设小写字母的数值是连续的，大写字母也是如此。或者你可以使用ctypc,h库中的合适的函数来区分大小写。  
[答题代码(8003)](C_Primer_Plus_code/8003/main.c)  

4. 编写一个程序，把输入作为字符流读取，直至遇到EOF。令其报告每个单词的平均字母数。不要将空白字符记为单词中的字母。实际上，标点符号也不应该计算，但现在不必考虑这一点(如果您想做得好一些，可以考虑使用ctype.h系列中的ispunct()函数）。  
[答题代码(8004)](C_Primer_Plus_code/8004/main.c)  

5. 修改程序清单8,4中的猜测程序，使其使用更智能的猜测策略。例如，程序最初猜50，让其询问用户该猜测值是大、小还是正确。如果该猜测值小，则令下一次猜测值为50和100的中值，也就是75。如果75大，则下一次猜测值为75和50的中值，等等。使用这种二分搜索(binary search)策略，起码如果用户没有欺骗，该程序很快会获得正确答案。  
[答题代码(8005)](C_Primer_Plus_code/8005/main.c)  

6. 修改程序清单8.8中的get_first()函数，使其返回所遇到的第一个非空白字符。在一个简单的程序中测试该函数。  
[答题代码(8006)](C_Primer_Plus_code/8006/main.c)  

7. 修改第7章的练习8，使菜单选项由字符代替数字进行标记。  
[答题代码(8007)](C_Primer_Plus_code/8007/main.c)  

8. 编写一个程序，显示一个菜单，为您提供加法、减法、乘法或除法的选项。获得您的选择后，该程序请求两个数，然后执行您选择的操作。该程序应该只接受它所提供的菜单选项。它应该使用float类型的数，并且如果用户未能输入数字应允许其重新输入。在除法的情况中，如果用户输入O作为第二个数，该程序应该提示用户输入一个新的值。一个典型的程序运行应该如下所示：  
Enter the operation of your choice:  
a. add s. subtract  
m. multiply d. divide  
q. quic  
  **a**  
Enter first number: **22.4**  
Enter second number: **one**  
one is not an number.  
Please enter a number, such as 2.5. -1.78E8, or 3: **1**  
 22.4 + 1 = 23.4  
Enter the operation of your choice:  
a. add s. subtract  
m. multiply d. divide  
q. quit  
  **d**  
Enter first number: **18.4**  
Enter second number: **O**  
Enter a number other than 0: **0.2**  
 18.4 / 0.2 = 92  
Enter the operation of your choice:  
a. add s. subtract  
m. multiply d. divide  
q. quit  
 **q**  
Bye.  
[答题代码(8008)](C_Primer_Plus_code/8008/main.c) 